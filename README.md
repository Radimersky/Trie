<h1>Domácí úkol č. 4: Trie</h1>
<p><em>Trie</em> (čti [trí] nebo [traj]) neboli prefixový strom je datová struktura, která se používá pro implementaci slovníků, v nichž jsou klíči řetězce znaků. Jedná se tedy o alternativu k implementacím pomocí vyhledávacích stromů (jakou používá <code>std::map</code>) nebo hashovacích tabulek (<code>std::unordered_map</code>). Na trie se v podstatě můžeme dívat jako na konečný automat stromového tvaru, v jehož akceptujících stavech jsou uchovávány hodnoty. Více o této datové struktuře naleznete na <a href="https://en.wikipedia.org/wiki/Trie">Wikipedii</a>.</p>
<p>Cílem této úlohy je implementovat tuto datovou strukturu společně se základními operacemi. Ukázku trie vidíme na obrázku níže:</p>
<p><img src="trie.png" /><br />
</p>
<p>Obrázek ukazuje trie s abecedou danou malými písmeny anglické abecedy a s celočíselnými hodnotami; tato datová struktura reprezentuje následující slovník:</p>
<ul>
<li>klíči „a“ přísluší hodnota -7,</li>
<li>klíči „ale“ přísluší hodnota 14,</li>
<li>klíči „ape“ přísluší hodnota 21,</li>
<li>klíči „at“ přísluší hodnota 5,</li>
<li>klíči „cat“ přísluší hodnota 100.</li>
</ul>
<p>Trie podporuje běžné slovníkové operace vložení položky (klíče a hodnoty), vyhledání položky podle klíče a vymazání položky. Kromě těchto základních operací budeme ještě chtít vrácení seznamu všech položek trie a vykreslení trie. Všechny požadované operace jsou podrobněji rozepsány níže.</p>
<p>Protože položky trie se mohou mazat, budeme chtít, aby platil následující invariant: Ve stromové struktuře trie nesmí být <em>kromě kořene</em> žádný list, který neobsahuje žádnou hodnotu. Výjimka pro kořen zde je kvůli zjednodušení, abychom mohli předpokládat, že každá trie (i prázdná) má kořen.</p>
<h2 id="zadání">Zadání</h2>
<p>Stáhněte si soubory s kostrou zadání.</p>
<p>Vytvořte šablonovanou třídu <code>Trie</code>, která bude reprezentovat datovou strukturu trie popsanou výše. Tato třída má dva šablonové parametry. Parametr <code>Alphabet</code> popisuje abecedu klíčů trie, parametr <code>Value</code> je typem hodnot, které budeme do trie ukládat.</p>
<p>Od třídy, kterou dosadíme za parametr Alphabet, se očekává, že bude obsahovat následující statické položky:</p>
<ul>
<li><code class="sourceCode cpp"><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> size</code> – statickou konstantu popisující počet písmen abecedy (smíte předpokládat, že je to číslo &gt; 0);</li>
<li>statickou metodu <code class="sourceCode cpp"><span class="at">static</span> <span class="dt">int</span> ord(<span class="dt">char</span> letter)</code>, která pro zadaný znak vrací pořadí daného znaku v abecedě z intervalu <span class="math inline">[0, <em>s</em><em>i</em><em>z</em><em>e</em> − 1]</span>; pro znaky mimo rozsah abecedy vrací −1;</li>
<li>statickou metodu <code class="sourceCode cpp"><span class="at">static</span> <span class="dt">char</span> chr(<span class="dt">int</span> index)</code>, která vrátí znak v abecedě odpovídající zadanému pořadí; chování této funkce pro indexy mimo interval <span class="math inline">[0, <em>s</em><em>i</em><em>z</em><em>e</em> − 1]</span> není definováno.</li>
</ul>
<p>V souboru <code>alphabet.h</code> najdete nějaké již připravené abecedy; např. <code>LowerCaseAlphabet</code> je abeceda, která má <code>size</code> rovno 26 a mapuje znaky <code>'a'</code> až <code>'z'</code> na čísla 0 až 25. V souboru <code>morse.cpp</code> je ukázka použití Trie se znaky Morseovy abecedy <code>MorseCode</code>.</p>
<p>Ve třídě <code>Trie</code> nemusíte nijak ověřovat, že zadaný parametr Alphabet skutečně splňuje tyto požadavky. Prostě to předpokládejte. Testy budou používat jen korektní abecedy. (Ale mohou používat i jiné, než ty definované v <code>alphabet.h</code>.)</p>
<p>Třída <code>Trie</code> musí obsahovat veřejnou vnitřní třídu <code>Node</code> určenou k reprezentaci jednotlivých uzlů. Každý uzel může obsahovat hodnotu typu Value. Pokud uzel žádnou hodnotu neobsahuje, nesmí se ani žádný objekt typu Value vytvořit (viz Poznámky níže).</p>
<p>Třída <code>Node</code> musí obsahovat následující veřejné metody, jejichž účelem je umožnit testovat, zda má trie správný tvar.</p>
<ul>
<li><code class="sourceCode cpp">child(<span class="dt">char</span> letter)</code> vrátí ukazatel na potomka, který odpovídá zadanému znaku; pokud uzel takového potomka nemá, vrátí tato funkce <code class="sourceCode cpp"><span class="kw">nullptr</span></code>; pokud je zadaný znak mimo rozsah abecedy (tj. <code>Alphabet::ord(letter)</code> vrátí −1), pak tato funkce vyhodí výjimku typu <code>std::out_of_range</code>.</li>
<li><code>parent()</code> vrací ukazatel na rodiče uzlu nebo <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, pokud je uzel kořenem trie.</li>
<li><code>value()</code> vrací ukazatel na hodnotu obsaženou v uzlu nebo <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, pokud uzel žádnou hodnotu nemá.</li>
</ul>
<p>Ukazatele vrácené těmito metodami nesmí dovolit modifikaci uzlu. Třída <code>Node</code> nesmí mít žádné další veřejné metody – můžete si samozřejmě vytvořit libovolné množství metod soukromých. Rovněž můžete definovat veřejné konstruktory třídy <code>Node</code> (ve skutečné implementaci bychom se tomu asi chtěli vyhnout, ale tady to může implementaci mírně usnadnit, a proto to je povoleno).</p>
<p>Třída <code>Trie</code> musí mít následující veřejné metody <strong>(kde <code>key</code> je parametr, do kterého je možno předat objekt typu <code>std::string</code>)</strong>:</p>
<ul>
<li><code>root()</code> vrací <em>referenci</em> na kořenový uzel trie. Vrácená reference nesmí dovolit modifikaci kořenového uzlu.</li>
<li><code>empty()</code> vrací <code class="sourceCode cpp"><span class="kw">true</span></code>, pokud je trie prázdná, jinak vrací <code class="sourceCode cpp"><span class="kw">false</span></code>.</li>
<li><code>search(key)</code> vrací ukazatel na hodnotu, která přísluší zadanému klíči, nebo <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, pokud zadanému klíči nepřísluší žádná hodnota. Tato metoda musí mít dvě verze: jedna dovolí měnit nalezenou hodnotu, druhá ne.</li>
<li><code>at(key)</code> funguje podobně jako search s tím rozdílem, že vrací <em>referenci</em> na hodnotu. Pokud zadanému klíči nepřísluší žádná hodnota, vyhodí výjimku typu <code>std::out_of_range</code>. (Chová se tedy podobně jako <code>at()</code> u standardních kontejnerů.) Tato metoda musí mít opět dvě verze.</li>
<li><code>remove(key)</code> odstraní z trie položku se zadaným klíčem. Pokud se položka s daným klíčem v trie nevyskytuje, nestane se nic. Nezapomeňte, že je třeba udržovat invariant, že trie nesmí obsahovat listy bez hodnoty (kromě kořene).</li>
<li><code>insert(key, value)</code> se pokusí vložit do trie novou položku s daným klíčem a danou hodnotou. Pokud už položka s daným klíčem v trie existuje, vložení se nezdaří. Metoda vrací <code class="sourceCode cpp"><span class="kw">true</span></code> nebo <code class="sourceCode cpp"><span class="kw">false</span></code> podle toho, jestli se vložení položky podařilo. V případě, že se vložení nepodařilo, nesmí se vytvořit zbytečná kopie zadané hodnoty.</li>
<li><code>operator[](key)</code> se chová podobně jako operátor <code>[]</code> u standardních kontejnerů <code>std::map</code> a <code>std::unordered_map</code>, tj. pokud v trie existuje položka s daným klíčem, vrátí <em>referenci</em> na příslušnou hodnotu; pokud neexistuje, vytvoří se nová položka s hodnotou vytvořenou defaultním konstruktorem a vrátí se <em>reference</em> na tuto novou hodnotu.</li>
<li><code>clear()</code> vymaže všechny položky z trie.</li>
</ul>
<p><strong>Upřesnění:</strong> Metody <code>search</code>, <code>insert</code>, <code>remove</code>, <code>at</code> a operátor <code>[]</code> vyhodí výjimku typu <code>std::out_of_range</code>, pokud se v zadaném klíči objeví znak, který nepatří do zadané abecedy. Pro usnadnění ovšem tohle u metod <code>search</code>, <code>at</code> a <code>remove</code> testujeme jen v případech, kdy je část klíče před špatným znakem existující cestou v trie. Pokud je tedy trie jako na obrázku výše s abecedou malých písmen anglické abecedy, pak <code class="sourceCode cpp">trie.search(<span class="st">&quot;cat!&quot;</span>)</code> musí určitě vyhodit výjimku, zatímco <code class="sourceCode cpp">trie.search(<span class="st">&quot;catapult$&quot;</span>)</code> výjimku vyhodit nemusí a může vrátit <code class="sourceCode cpp"><span class="kw">nullptr</span></code>.</p>
<p><strong>Poznámka:</strong> Invariant trie zmíněný výše musí zůstat zachován i v případě vyhození výjimky.</p>
<p>Dále musí obsahovat následující metody, jejichž podrobnější popis je níže.</p>
<ul>
<li><code>items()</code> vrátí seznam všech položek trie.</li>
<li><code class="sourceCode cpp">draw(<span class="bu">std::</span>ostream&amp; output)</code> vypíše na výstup stromovou strukturu trie ve formátu Graphviz.</li>
</ul>
<p>Kromě těchto metod také musíte zajistit, aby byly objekty třídy Trie kopírovatelné, a to jak při inicializaci, tak při přiřazení.</p>
<h3 id="složitost-operací">Složitost operací</h3>
<p>Smyslem trie je být efektivní implementací slovníku, proto je při programování jednotlivých operací třeba myslet na jejich složitost. Je třeba dodržet následující:</p>
<ul>
<li>metody <code>root()</code>, <code>empty()</code> a všechny metody třídy <code>Node</code> musí mít konstantní složitost;</li>
<li>metody <code>search()</code>, <code>at()</code>, <code>insert()</code>, <code>remove()</code> a operátor <code>[]</code> musí mít složitost nejvýše lineární vzhledem k délce zadaného klíče;</li>
<li>metody <code>clear()</code>, <code>items()</code>, <code>draw()</code> musí mít složitost nejvýše lineární vzhledem k velikosti trie.</li>
</ul>
<p><em>Poznámka:</em> Do složitosti operací nepočítáme čas nutný pro vytváření/kopírování hodnot typu Value. Rovněž nepočítáme časovou složitost statických metod <code>ord</code> a <code>chr</code> definovaných ve specifikaci abecedy.</p>
<p>Složitost operací přímo netestujeme (kromě toho, že testy mají timeout, ale to nemusí zachytit všechny problémy). Pokud opravující při hodnocení zjistí, že některé metody jsou implementovány se špatnou složitostí, sníží hodnocení čistoty kódu o jeden až tři body, podle toho, kolik metod je implementováno se špatnou složitostí a jak závažně jste se od požadované složitosti odchýlili. <em>Toto snížení může u tohoto úkolu vést i k záporným bodům za čistotu kódu.</em></p>
<h3 id="vrácení-seznamu-všech-položek-trie-items">Vrácení seznamu všech položek trie: <code>items()</code></h3>
<p>Pro reprezentaci seznamu položek trie budeme používat typ <code>std::vector&lt;std::pair&lt;std::string, const Value&amp;&gt;&gt;</code>. Protože opisovat tento typ vícekrát by nebylo příjemné, máte v kostře zadání připraven typový alias <code>ItemList</code>. Metoda <code>items()</code> tedy bude vracet hodnotu tohoto typu. Položky v seznamu musí být v lexikografickém uspořádání podle klíčů (přitom jednotlivé znaky se řadí v pořadí daném <code>Alphabet::ord</code>). To se zajistí vhodným způsobem procházení trie; rozhodně není potřeba seznam nějak explicitně řadit.</p>
<p><em>Poznámka:</em> Řešením více v duchu standardní knihovny by bylo místo této metody implementovat iterátory. To je ovšem v tomto případě poněkud obtížné, proto jsme dali přednost tomuto způsobu procházení položek.</p>
<h3 id="vykreslení-trie-ve-formátu-graphviz-drawstdostream-output">Vykreslení trie ve formátu Graphviz: <code>draw(std::ostream&amp; output)</code></h3>
<p>Metoda <code>draw(std::ostream&amp; output)</code> vypíše trie do zadaného výstupního proudu v textovém formátu <em>dot</em> nástroje <a href="http://graphviz.org/">Graphviz</a>, což je populární software pro kreslení grafů. Formát <em>dot</em> umožňuje specifikovat hrany v grafu a různá nastavení vykreslování. My se zde omezíme pouze na specifikaci hran a popisů v uzlech a na hranách.</p>
<p>Trie z obrázku nahoře (bez barev) se dá ve formátu <em>dot</em> napsat například takto:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode dot"><code class="sourceCode dot"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">digraph</span> <span class="ot">{</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">	</span><span class="st">&quot;A&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">	</span><span class="st">&quot;A&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;B&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;a&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">	</span><span class="st">&quot;B&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;-7&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co">	</span><span class="st">&quot;B&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;C&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;l&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co">	</span><span class="st">&quot;C&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="co">	</span><span class="st">&quot;C&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;D&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;e&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="co">	</span><span class="st">&quot;D&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;14&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="co">	</span><span class="st">&quot;B&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;E&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;p&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="co">	</span><span class="st">&quot;E&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="co">	</span><span class="st">&quot;E&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;F&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;e&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="co">	</span><span class="st">&quot;F&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;21&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="co">	</span><span class="st">&quot;B&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;G&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;t&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="co">	</span><span class="st">&quot;G&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;5&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="co">	</span><span class="st">&quot;A&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;H&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;c&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="co">	</span><span class="st">&quot;H&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="co">	</span><span class="st">&quot;H&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;I&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;a&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="co">	</span><span class="st">&quot;I&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="co">	</span><span class="st">&quot;I&quot;</span><span class="co"> </span><span class="ot">-&gt;</span><span class="co"> </span><span class="st">&quot;J&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;t&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="co">	</span><span class="st">&quot;J&quot;</span><span class="co"> </span><span class="ot">[</span><span class="at">label</span><span class="ot">=</span><span class="st">&quot;100&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="ot">}</span></a></code></pre></div>
<p>Specifikace uzlů je tedy <code>&quot;id uzlu&quot; [label=&quot;popisek&quot;]</code>, specifikace hrany je <code>&quot;id uzlu odkud&quot; -&gt; &quot;id uzlu kam&quot; [label=&quot;popisek&quot;]</code>. Jako id uzlu je možno použít libovolné řetězce (nemusí to nutně být A, B, C, …).</p>
<p>Pro účely testování se pokuste dodržet naznačený formát, tj.: jedna specifikace uzlu nebo hrany na řádku; uzly bez hodnot mají prázdný popisek, uzly s hodnotami mají v popisku hodnotu; hrany mají popisek daný znakem, který odpovídá pořadí potomka. Testy fungují nezávisle na id uzlů, důležité je, jestli jsou správně popisky a tvar trie.</p>
<p><em>Poznámka:</em> Existuje i webová verze <a href="http://webgraphviz.com/" class="uri">http://webgraphviz.com</a>, kde si můžete zobrazit svůj výstup, aniž byste museli něco instalovat.</p>
<h2 id="požadavky">Požadavky</h2>
<ul>
<li><p>Pište si testy. Nezapomeňte v testech instanciovat všechny metody. Na spoustu kompilačních problémů se přijde až tehdy, když je metoda obsahující chybu někde instanciovaná.</p></li>
<li><p>Dodržujte zásady správného programování.</p></li>
<li>Zejména se pokuste zamezit <strong>duplikaci kódu</strong>. To se v tomto úkolu týká zejména kódu pro procházení trie. Protože implementovat zadání tak, aby se v kódu procházení trie objevilo pouze jednou, není úplně jednoduché a vyžaduje to pokročilejší použití šablon, bude nám stačit, když se procházení trie v kódu objeví nejvýše dvakrát.
<ul>
<li>Upřesnění: Procházením trie se zde myslí ta činnost, kterou musí vykonat metody, které hledají v trie podle zadaného klíče, tedy metody <code>search</code>, <code>at</code>, <code>insert</code>, <code>remove</code> a operátor <code>[]</code>. Tento bod se tedy netýká metod <code>items</code> a <code>draw</code>. V metodě <code>remove</code> se tento bod týká pouze nalezení prvku ke smazání, ne případné další činnosti nutné k zachování invariantu.</li>
</ul></li>
<li><p>Nezapomínejte na <code class="sourceCode cpp"><span class="at">const</span></code>. Dobře si rozmyslete, které metody mají být konstantní a které ne, které parametry se mají brát konstantní referencí apod.</p></li>
<li><p>K dosažení výše uvedených cílů smíte v této úloze na vhodných místech použít <code class="sourceCode cpp"><span class="kw">const_cast</span></code>. Nezapomeňte ovšem na jeho správné použití (konstantní metoda dělá skutečnou práci, nekonstantní metoda používá přetypování).</p></li>
<li><p>Jako vždy, nesmí docházet k žádným chybám správy paměti (memory leaky, špatné čtení paměti, použití neinicializovaných proměnných).</p></li>
<li><p>Používejte prostředků moderního C++; zejména se ve vašem kódu nikde nesmí objevit operátor <code class="sourceCode cpp"><span class="kw">delete</span></code>. Dobře si rozmyslete, které ukazatele mají být <code>unique_ptr</code> a kde je vhodné použít klasické „syrové“ ukazatele.</p></li>
<li><p>Veřejné rozhraní tříd musí být takové, jak je uvedeno výše. Kód nesmí obsahovat žádné další veřejné metody nebo atributy. Samozřejmě si můžete definovat libovolné množství soukromých metod a atributů.</p></li>
</ul>
<h2 id="poznámky">Poznámky</h2>
<p>K udržování hodnoty v uzlech můžete použít <code>std::unique_ptr</code>. Kdo se cítí odvážně, může se podívat na třídu <code>std::optional</code>, která se k tomuto účelu hodí ještě lépe. Je ve standardní knihovně až od standardu C++17, takže je třeba mít dostatečně nový kompilátor a novou verzi knihovny.</p>
<h2 id="bonus">Bonus</h2>
<ul>
<li><p>Můžete získat 1 bonusový bod, pokud zvládnete implementovat zadání bez větší duplikace kódu (tj. procházení trie maximálně na dvou místech, viz výše) a bez použití <code class="sourceCode cpp"><span class="kw">const_cast</span></code>. Rovněž nesmíte používat makra.</p></li>
<li><p>Můžete získat 2 bonusové body, pokud zvládnete implementovat zadání úplně bez duplikace kódu (tj. procházení trie na jediném místě v kódu) a bez použití <code class="sourceCode cpp"><span class="kw">const_cast</span></code>. Stejně jako v minulém bodě, nesmíte používat makra.</p></li>
</ul>
  </div>
